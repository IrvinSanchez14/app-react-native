/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.14.0 (NJsonSchema v9.13.18.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class MenuClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets accessible paths based on user credentials
     */
    getUserMenu(): Promise<MenuResponse | null> {
        let url_ = this.baseUrl + "/menu";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserMenu(_response);
        });
    }

    protected processGetUserMenu(response: Response): Promise<MenuResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuResponse.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MenuResponse | null>(<any>null);
    }

    /**
     * Adds application to user's favorite list
     */
    addUserFavorite(fullRunCode: string | null): Promise<void> {
        let url_ = this.baseUrl + "/menu/favorite/{fullRunCode}";
        if (fullRunCode === undefined || fullRunCode === null)
            throw new Error("The parameter 'fullRunCode' must be defined.");
        url_ = url_.replace("{fullRunCode}", encodeURIComponent("" + fullRunCode)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddUserFavorite(_response);
        });
    }

    protected processAddUserFavorite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Removes application from user's favorite list
     */
    removeUserFavorite(fullRunCode: string | null): Promise<void> {
        let url_ = this.baseUrl + "/menu/favorite/{fullRunCode}";
        if (fullRunCode === undefined || fullRunCode === null)
            throw new Error("The parameter 'fullRunCode' must be defined.");
        url_ = url_.replace("{fullRunCode}", encodeURIComponent("" + fullRunCode)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveUserFavorite(_response);
        });
    }

    protected processRemoveUserFavorite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Updates user's favorite item weights
     */
    reorderUserFavorites(command: ReorderFavoritesCommand): Promise<void> {
        let url_ = this.baseUrl + "/menu/favorites";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReorderUserFavorites(_response);
        });
    }

    protected processReorderUserFavorites(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class CPRClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Returns open checks for an account
     * @param accountNumber Account Number
     */
    getOpenChecks(accountNumber: string | null): Promise<OpenChecksResponse | null> {
        let url_ = this.baseUrl + "/cpr/account/{accountNumber}/checks/open";
        if (accountNumber === undefined || accountNumber === null)
            throw new Error("The parameter 'accountNumber' must be defined.");
        url_ = url_.replace("{accountNumber}", encodeURIComponent("" + accountNumber)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOpenChecks(_response);
        });
    }

    protected processGetOpenChecks(response: Response): Promise<OpenChecksResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OpenChecksResponse.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OpenChecksResponse | null>(<any>null);
    }

    /**
     * Returns open invoices for an account
     * @param accountNumber Account Number
     */
    getOpenInvoices(accountNumber: string | null): Promise<OpenInvoicesResponse | null> {
        let url_ = this.baseUrl + "/cpr/account/{accountNumber}/invoices/open";
        if (accountNumber === undefined || accountNumber === null)
            throw new Error("The parameter 'accountNumber' must be defined.");
        url_ = url_.replace("{accountNumber}", encodeURIComponent("" + accountNumber)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOpenInvoices(_response);
        });
    }

    protected processGetOpenInvoices(response: Response): Promise<OpenInvoicesResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OpenInvoicesResponse.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OpenInvoicesResponse | null>(<any>null);
    }

    /**
     * Returns payment history for an account
     * @param query Account Payment Filter Information
     */
    getAccountPaymentHistory(query: AccountPaymentHistoryQuery): Promise<AccountPaymentHistoryResponse | null> {
        let url_ = this.baseUrl + "/cpr/payments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAccountPaymentHistory(_response);
        });
    }

    protected processGetAccountPaymentHistory(response: Response): Promise<AccountPaymentHistoryResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccountPaymentHistoryResponse.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccountPaymentHistoryResponse | null>(<any>null);
    }

    /**
     * Returns Base64 encoded PDF of payment
     * @param paymentId Payment Id
     */
    getPaymentPDF(paymentId: number): Promise<PaymentPDFResponse | null> {
        let url_ = this.baseUrl + "/cpr/payment/{paymentId}";
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaymentPDF(_response);
        });
    }

    protected processGetPaymentPDF(response: Response): Promise<PaymentPDFResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PaymentPDFResponse.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentPDFResponse | null>(<any>null);
    }

    /**
     * Applies payment to invoices for a given check number
     * @param command Payment information
     */
    applyPaymentToInvoices(command: ApplyPaymentToInvoicesCommand): Promise<void> {
        let url_ = this.baseUrl + "/cpr/payment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplyPaymentToInvoices(_response);
        });
    }

    protected processApplyPaymentToInvoices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Returns all adjustment types
     */
    adjustmentTypes(): Promise<AdjustmentTypesResponse | null> {
        let url_ = this.baseUrl + "/cpr/adjustmenttypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdjustmentTypes(_response);
        });
    }

    protected processAdjustmentTypes(response: Response): Promise<AdjustmentTypesResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AdjustmentTypesResponse.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AdjustmentTypesResponse | null>(<any>null);
    }
}

export class NotificationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Send email using template
     * @param command Email information
     */
    sendTemplatedEmail(command: EmailCommand): Promise<void> {
        let url_ = this.baseUrl + "/notification/email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendTemplatedEmail(_response);
        });
    }

    protected processSendTemplatedEmail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class SearchClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Searches customers
     */
    searchPreview(query: CustomerPreviewQuery): Promise<CustomerPreviewResponse | null> {
        let url_ = this.baseUrl + "/search/customer/preview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchPreview(_response);
        });
    }

    protected processSearchPreview(response: Response): Promise<CustomerPreviewResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerPreviewResponse.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerPreviewResponse | null>(<any>null);
    }

    /**
     * Searches customers
     */
    searchDetail(query: CustomerDetailQuery): Promise<CustomerDetailResponse | null> {
        let url_ = this.baseUrl + "/search/customer/detail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchDetail(_response);
        });
    }

    protected processSearchDetail(response: Response): Promise<CustomerDetailResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerDetailResponse.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerDetailResponse | null>(<any>null);
    }

    /**
     * Returns user's branch groups
     */
    getUserBranchGroups(): Promise<BranchGroupsResponse | null> {
        let url_ = this.baseUrl + "/search/branchgroups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserBranchGroups(_response);
        });
    }

    protected processGetUserBranchGroups(response: Response): Promise<BranchGroupsResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BranchGroupsResponse.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BranchGroupsResponse | null>(<any>null);
    }

    /**
     * Returns all item classes (with sections)
     */
    getItemClasses(): Promise<ItemClassesResponse | null> {
        let url_ = this.baseUrl + "/search/item/categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetItemClasses(_response);
        });
    }

    protected processGetItemClasses(response: Response): Promise<ItemClassesResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ItemClassesResponse.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ItemClassesResponse | null>(<any>null);
    }

    /**
     * Searches items
     * @param query Item Search Information
     */
    getItem(query: ItemsQuery): Promise<ItemsResponse | null> {
        let url_ = this.baseUrl + "/search/item/detail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetItem(_response);
        });
    }

    protected processGetItem(response: Response): Promise<ItemsResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ItemsResponse.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ItemsResponse | null>(<any>null);
    }

    /**
     * Returns item availability
     */
    getItemAvailability(itemNumber: string | null): Promise<ItemAvailabilityResponse | null> {
        let url_ = this.baseUrl + "/search/item/{itemNumber}/availability";
        if (itemNumber === undefined || itemNumber === null)
            throw new Error("The parameter 'itemNumber' must be defined.");
        url_ = url_.replace("{itemNumber}", encodeURIComponent("" + itemNumber)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetItemAvailability(_response);
        });
    }

    protected processGetItemAvailability(response: Response): Promise<ItemAvailabilityResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ItemAvailabilityResponse.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ItemAvailabilityResponse | null>(<any>null);
    }

    /**
     * Returns order detail
     * @param orderNumber Order Number
     */
    getOrder(orderNumber: string | null): Promise<OrderResponse | null> {
        let url_ = this.baseUrl + "/search/order/{orderNumber}";
        if (orderNumber === undefined || orderNumber === null)
            throw new Error("The parameter 'orderNumber' must be defined.");
        url_ = url_.replace("{orderNumber}", encodeURIComponent("" + orderNumber)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOrder(_response);
        });
    }

    protected processGetOrder(response: Response): Promise<OrderResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrderResponse.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderResponse | null>(<any>null);
    }
}

export class RegisterTrackerClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Returns stores and corresponding list of registers for each store
     */
    stores(): Promise<StoreListResponse | null> {
        let url_ = this.baseUrl + "/registertracker/stores";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStores(_response);
        });
    }

    protected processStores(response: Response): Promise<StoreListResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StoreListResponse.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StoreListResponse | null>(<any>null);
    }

    /**
     * Returns store by store number and corresponding list of registers
     */
    store(storeNumber: number): Promise<StoreResponse | null> {
        let url_ = this.baseUrl + "/registertracker/store/{storeNumber}";
        if (storeNumber === undefined || storeNumber === null)
            throw new Error("The parameter 'storeNumber' must be defined.");
        url_ = url_.replace("{storeNumber}", encodeURIComponent("" + storeNumber)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStore(_response);
        });
    }

    protected processStore(response: Response): Promise<StoreResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StoreResponse.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StoreResponse | null>(<any>null);
    }

    /**
     * Returns health information about register at specified hostname
     */
    health(hostname: string | null): Promise<HealthResponse | null> {
        let url_ = this.baseUrl + "/registertracker/health/{hostname}";
        if (hostname === undefined || hostname === null)
            throw new Error("The parameter 'hostname' must be defined.");
        url_ = url_.replace("{hostname}", encodeURIComponent("" + hostname)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHealth(_response);
        });
    }

    protected processHealth(response: Response): Promise<HealthResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HealthResponse.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HealthResponse | null>(<any>null);
    }
}

export class MenuResponse implements IMenuResponse {
    menuItems?: MenuItem[] | undefined;

    constructor(data?: IMenuResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["menuItems"] && data["menuItems"].constructor === Array) {
                this.menuItems = [] as any;
                for (let item of data["menuItems"])
                    this.menuItems!.push(MenuItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MenuResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MenuResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.menuItems && this.menuItems.constructor === Array) {
            data["menuItems"] = [];
            for (let item of this.menuItems)
                data["menuItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMenuResponse {
    menuItems?: MenuItem[] | undefined;
}

export class MenuItem implements IMenuItem {
    menuId!: number;
    parentMenuId?: number | undefined;
    title?: string | undefined;
    runCode?: string | undefined;
    fullRunCode?: string | undefined;
    applicationPath?: string | undefined;
    subItems?: MenuItem[] | undefined;

    constructor(data?: IMenuItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.menuId = data["menuId"];
            this.parentMenuId = data["parentMenuId"];
            this.title = data["title"];
            this.runCode = data["runCode"];
            this.fullRunCode = data["fullRunCode"];
            this.applicationPath = data["applicationPath"];
            if (data["subItems"] && data["subItems"].constructor === Array) {
                this.subItems = [] as any;
                for (let item of data["subItems"])
                    this.subItems!.push(MenuItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MenuItem {
        data = typeof data === 'object' ? data : {};
        let result = new MenuItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuId"] = this.menuId;
        data["parentMenuId"] = this.parentMenuId;
        data["title"] = this.title;
        data["runCode"] = this.runCode;
        data["fullRunCode"] = this.fullRunCode;
        data["applicationPath"] = this.applicationPath;
        if (this.subItems && this.subItems.constructor === Array) {
            data["subItems"] = [];
            for (let item of this.subItems)
                data["subItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMenuItem {
    menuId: number;
    parentMenuId?: number | undefined;
    title?: string | undefined;
    runCode?: string | undefined;
    fullRunCode?: string | undefined;
    applicationPath?: string | undefined;
    subItems?: MenuItem[] | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.title = data["title"];
            this.status = data["status"];
            this.detail = data["detail"];
            this.instance = data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data; 
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class ReorderFavoritesCommand implements IReorderFavoritesCommand {
    fullRunCodes?: string[] | undefined;

    constructor(data?: IReorderFavoritesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["fullRunCodes"] && data["fullRunCodes"].constructor === Array) {
                this.fullRunCodes = [] as any;
                for (let item of data["fullRunCodes"])
                    this.fullRunCodes!.push(item);
            }
        }
    }

    static fromJS(data: any): ReorderFavoritesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ReorderFavoritesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.fullRunCodes && this.fullRunCodes.constructor === Array) {
            data["fullRunCodes"] = [];
            for (let item of this.fullRunCodes)
                data["fullRunCodes"].push(item);
        }
        return data; 
    }
}

export interface IReorderFavoritesCommand {
    fullRunCodes?: string[] | undefined;
}

export class OpenChecksResponse implements IOpenChecksResponse {
    openChecks?: OpenCheck[] | undefined;

    constructor(data?: IOpenChecksResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["openChecks"] && data["openChecks"].constructor === Array) {
                this.openChecks = [] as any;
                for (let item of data["openChecks"])
                    this.openChecks!.push(OpenCheck.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OpenChecksResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OpenChecksResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.openChecks && this.openChecks.constructor === Array) {
            data["openChecks"] = [];
            for (let item of this.openChecks)
                data["openChecks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOpenChecksResponse {
    openChecks?: OpenCheck[] | undefined;
}

export class OpenCheck implements IOpenCheck {
    checkNumber?: string | undefined;
    receivedOn!: Date;
    amount?: string | undefined;

    constructor(data?: IOpenCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.checkNumber = data["checkNumber"];
            this.receivedOn = data["receivedOn"] ? new Date(data["receivedOn"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): OpenCheck {
        data = typeof data === 'object' ? data : {};
        let result = new OpenCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkNumber"] = this.checkNumber;
        data["receivedOn"] = this.receivedOn ? this.receivedOn.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IOpenCheck {
    checkNumber?: string | undefined;
    receivedOn: Date;
    amount?: string | undefined;
}

export class OpenInvoicesResponse implements IOpenInvoicesResponse {
    accountNumber?: string | undefined;
    openInvoices?: OpenInvoice[] | undefined;

    constructor(data?: IOpenInvoicesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountNumber = data["accountNumber"];
            if (data["openInvoices"] && data["openInvoices"].constructor === Array) {
                this.openInvoices = [] as any;
                for (let item of data["openInvoices"])
                    this.openInvoices!.push(OpenInvoice.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OpenInvoicesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OpenInvoicesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountNumber"] = this.accountNumber;
        if (this.openInvoices && this.openInvoices.constructor === Array) {
            data["openInvoices"] = [];
            for (let item of this.openInvoices)
                data["openInvoices"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOpenInvoicesResponse {
    accountNumber?: string | undefined;
    openInvoices?: OpenInvoice[] | undefined;
}

export class OpenInvoice implements IOpenInvoice {
    jobNumber?: string | undefined;
    referenceNumber?: string | undefined;
    invoiceType?: string | undefined;
    referenceNumber2?: string | undefined;
    poNumber?: string | undefined;
    sellingBranchName?: string | undefined;
    branchName?: string | undefined;
    invoiceDate!: Date;
    invoiceAmount!: number;
    amountDue!: number;
    taxAmount!: number;
    taxCode?: string | undefined;
    dueDate!: Date;
    orderNumber?: string | undefined;
    invoiceBackOrderNumber?: string | undefined;
    paymentAmount!: number;
    openAmount!: number;

    constructor(data?: IOpenInvoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.jobNumber = data["jobNumber"];
            this.referenceNumber = data["referenceNumber"];
            this.invoiceType = data["invoiceType"];
            this.referenceNumber2 = data["referenceNumber2"];
            this.poNumber = data["poNumber"];
            this.sellingBranchName = data["sellingBranchName"];
            this.branchName = data["branchName"];
            this.invoiceDate = data["invoiceDate"] ? new Date(data["invoiceDate"].toString()) : <any>undefined;
            this.invoiceAmount = data["invoiceAmount"];
            this.amountDue = data["amountDue"];
            this.taxAmount = data["taxAmount"];
            this.taxCode = data["taxCode"];
            this.dueDate = data["dueDate"] ? new Date(data["dueDate"].toString()) : <any>undefined;
            this.orderNumber = data["orderNumber"];
            this.invoiceBackOrderNumber = data["invoiceBackOrderNumber"];
            this.paymentAmount = data["paymentAmount"];
            this.openAmount = data["openAmount"];
        }
    }

    static fromJS(data: any): OpenInvoice {
        data = typeof data === 'object' ? data : {};
        let result = new OpenInvoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobNumber"] = this.jobNumber;
        data["referenceNumber"] = this.referenceNumber;
        data["invoiceType"] = this.invoiceType;
        data["referenceNumber2"] = this.referenceNumber2;
        data["poNumber"] = this.poNumber;
        data["sellingBranchName"] = this.sellingBranchName;
        data["branchName"] = this.branchName;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["invoiceAmount"] = this.invoiceAmount;
        data["amountDue"] = this.amountDue;
        data["taxAmount"] = this.taxAmount;
        data["taxCode"] = this.taxCode;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["orderNumber"] = this.orderNumber;
        data["invoiceBackOrderNumber"] = this.invoiceBackOrderNumber;
        data["paymentAmount"] = this.paymentAmount;
        data["openAmount"] = this.openAmount;
        return data; 
    }
}

export interface IOpenInvoice {
    jobNumber?: string | undefined;
    referenceNumber?: string | undefined;
    invoiceType?: string | undefined;
    referenceNumber2?: string | undefined;
    poNumber?: string | undefined;
    sellingBranchName?: string | undefined;
    branchName?: string | undefined;
    invoiceDate: Date;
    invoiceAmount: number;
    amountDue: number;
    taxAmount: number;
    taxCode?: string | undefined;
    dueDate: Date;
    orderNumber?: string | undefined;
    invoiceBackOrderNumber?: string | undefined;
    paymentAmount: number;
    openAmount: number;
}

export class AccountPaymentHistoryResponse implements IAccountPaymentHistoryResponse {
    invoicePayments?: Transaction[] | undefined;
    totalResults!: number;

    constructor(data?: IAccountPaymentHistoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["invoicePayments"] && data["invoicePayments"].constructor === Array) {
                this.invoicePayments = [] as any;
                for (let item of data["invoicePayments"])
                    this.invoicePayments!.push(Transaction.fromJS(item));
            }
            this.totalResults = data["totalResults"];
        }
    }

    static fromJS(data: any): AccountPaymentHistoryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccountPaymentHistoryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.invoicePayments && this.invoicePayments.constructor === Array) {
            data["invoicePayments"] = [];
            for (let item of this.invoicePayments)
                data["invoicePayments"].push(item.toJSON());
        }
        data["totalResults"] = this.totalResults;
        return data; 
    }
}

export interface IAccountPaymentHistoryResponse {
    invoicePayments?: Transaction[] | undefined;
    totalResults: number;
}

export class Transaction implements ITransaction {
    paymentId!: number;
    accountNumber?: string | undefined;
    invoiceNumber?: string | undefined;
    checkNumber?: string | undefined;
    appliedOn!: Date;
    amount?: string | undefined;
    auxiliaryReference?: string | undefined;
    submittedBy?: string | undefined;

    constructor(data?: ITransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.accountNumber = data["accountNumber"];
            this.invoiceNumber = data["invoiceNumber"];
            this.checkNumber = data["checkNumber"];
            this.appliedOn = data["appliedOn"] ? new Date(data["appliedOn"].toString()) : <any>undefined;
            this.amount = data["amount"];
            this.auxiliaryReference = data["auxiliaryReference"];
            this.submittedBy = data["submittedBy"];
        }
    }

    static fromJS(data: any): Transaction {
        data = typeof data === 'object' ? data : {};
        let result = new Transaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["accountNumber"] = this.accountNumber;
        data["invoiceNumber"] = this.invoiceNumber;
        data["checkNumber"] = this.checkNumber;
        data["appliedOn"] = this.appliedOn ? this.appliedOn.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["auxiliaryReference"] = this.auxiliaryReference;
        data["submittedBy"] = this.submittedBy;
        return data; 
    }
}

export interface ITransaction {
    paymentId: number;
    accountNumber?: string | undefined;
    invoiceNumber?: string | undefined;
    checkNumber?: string | undefined;
    appliedOn: Date;
    amount?: string | undefined;
    auxiliaryReference?: string | undefined;
    submittedBy?: string | undefined;
}

export class AccountPaymentHistoryQuery implements IAccountPaymentHistoryQuery {
    accountNumber?: string | undefined;
    startOn!: Date;
    endOn!: Date;

    constructor(data?: IAccountPaymentHistoryQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountNumber = data["accountNumber"];
            this.startOn = data["startOn"] ? new Date(data["startOn"].toString()) : <any>undefined;
            this.endOn = data["endOn"] ? new Date(data["endOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AccountPaymentHistoryQuery {
        data = typeof data === 'object' ? data : {};
        let result = new AccountPaymentHistoryQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountNumber"] = this.accountNumber;
        data["startOn"] = this.startOn ? this.startOn.toISOString() : <any>undefined;
        data["endOn"] = this.endOn ? this.endOn.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAccountPaymentHistoryQuery {
    accountNumber?: string | undefined;
    startOn: Date;
    endOn: Date;
}

export class PaymentPDFResponse implements IPaymentPDFResponse {
    pdf?: string | undefined;

    constructor(data?: IPaymentPDFResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pdf = data["pdf"];
        }
    }

    static fromJS(data: any): PaymentPDFResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentPDFResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdf"] = this.pdf;
        return data; 
    }
}

export interface IPaymentPDFResponse {
    pdf?: string | undefined;
}

export class ApplyPaymentToInvoicesCommand implements IApplyPaymentToInvoicesCommand {
    checkNumber?: string | undefined;
    referenceNumber?: string | undefined;
    branch?: string | undefined;
    number?: string | undefined;
    job?: string | undefined;
    invoicePayments?: InvoicePayment[] | undefined;

    constructor(data?: IApplyPaymentToInvoicesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.checkNumber = data["checkNumber"];
            this.referenceNumber = data["referenceNumber"];
            this.branch = data["branch"];
            this.number = data["number"];
            this.job = data["job"];
            if (data["invoicePayments"] && data["invoicePayments"].constructor === Array) {
                this.invoicePayments = [] as any;
                for (let item of data["invoicePayments"])
                    this.invoicePayments!.push(InvoicePayment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplyPaymentToInvoicesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyPaymentToInvoicesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkNumber"] = this.checkNumber;
        data["referenceNumber"] = this.referenceNumber;
        data["branch"] = this.branch;
        data["number"] = this.number;
        data["job"] = this.job;
        if (this.invoicePayments && this.invoicePayments.constructor === Array) {
            data["invoicePayments"] = [];
            for (let item of this.invoicePayments)
                data["invoicePayments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IApplyPaymentToInvoicesCommand {
    checkNumber?: string | undefined;
    referenceNumber?: string | undefined;
    branch?: string | undefined;
    number?: string | undefined;
    job?: string | undefined;
    invoicePayments?: InvoicePayment[] | undefined;
}

export class InvoicePayment implements IInvoicePayment {
    invoiceNumber!: number;
    jobNumber?: string | undefined;
    sellBranch?: string | undefined;
    paymentAmount!: number;
    invoiceAdjustments?: Adjustment[] | undefined;

    constructor(data?: IInvoicePayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.invoiceNumber = data["invoiceNumber"];
            this.jobNumber = data["jobNumber"];
            this.sellBranch = data["sellBranch"];
            this.paymentAmount = data["paymentAmount"];
            if (data["invoiceAdjustments"] && data["invoiceAdjustments"].constructor === Array) {
                this.invoiceAdjustments = [] as any;
                for (let item of data["invoiceAdjustments"])
                    this.invoiceAdjustments!.push(Adjustment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvoicePayment {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicePayment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceNumber"] = this.invoiceNumber;
        data["jobNumber"] = this.jobNumber;
        data["sellBranch"] = this.sellBranch;
        data["paymentAmount"] = this.paymentAmount;
        if (this.invoiceAdjustments && this.invoiceAdjustments.constructor === Array) {
            data["invoiceAdjustments"] = [];
            for (let item of this.invoiceAdjustments)
                data["invoiceAdjustments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IInvoicePayment {
    invoiceNumber: number;
    jobNumber?: string | undefined;
    sellBranch?: string | undefined;
    paymentAmount: number;
    invoiceAdjustments?: Adjustment[] | undefined;
}

export class Adjustment implements IAdjustment {
    adjustmentType!: AdjustmentTypes;
    amount!: number;

    constructor(data?: IAdjustment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adjustmentType = data["adjustmentType"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): Adjustment {
        data = typeof data === 'object' ? data : {};
        let result = new Adjustment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adjustmentType"] = this.adjustmentType;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IAdjustment {
    adjustmentType: AdjustmentTypes;
    amount: number;
}

export enum AdjustmentTypes {
    None = 0, 
    PriceConcession = 1, 
    Tax = 2, 
    Refund = 3, 
    ServiceCharge = 4, 
    LateFee = 5, 
    FuelSurcharge = 6, 
    SalesAllowance = 7, 
    TransferInvoice = 8, 
    BadDebtWriteOff = 9, 
    Bankruptcy = 10, 
    UnclaimedFunds = 11, 
    UnknownSuspense = 12, 
}

export class AdjustmentTypesResponse implements IAdjustmentTypesResponse {
    adjustmentTypes?: AdjustmentType[] | undefined;

    constructor(data?: IAdjustmentTypesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["adjustmentTypes"] && data["adjustmentTypes"].constructor === Array) {
                this.adjustmentTypes = [] as any;
                for (let item of data["adjustmentTypes"])
                    this.adjustmentTypes!.push(AdjustmentType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdjustmentTypesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AdjustmentTypesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.adjustmentTypes && this.adjustmentTypes.constructor === Array) {
            data["adjustmentTypes"] = [];
            for (let item of this.adjustmentTypes)
                data["adjustmentTypes"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAdjustmentTypesResponse {
    adjustmentTypes?: AdjustmentType[] | undefined;
}

export class AdjustmentType implements IAdjustmentType {
    name?: string | undefined;
    value!: number;

    constructor(data?: IAdjustmentType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): AdjustmentType {
        data = typeof data === 'object' ? data : {};
        let result = new AdjustmentType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface IAdjustmentType {
    name?: string | undefined;
    value: number;
}

export class EmailCommand implements IEmailCommand {
    templateName?: string | undefined;
    from?: string | undefined;
    to?: string[] | undefined;
    subject?: string | undefined;
    parameters?: KeyValuePairOfStringAndString[] | undefined;

    constructor(data?: IEmailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.templateName = data["templateName"];
            this.from = data["from"];
            if (data["to"] && data["to"].constructor === Array) {
                this.to = [] as any;
                for (let item of data["to"])
                    this.to!.push(item);
            }
            this.subject = data["subject"];
            if (data["parameters"] && data["parameters"].constructor === Array) {
                this.parameters = [] as any;
                for (let item of data["parameters"])
                    this.parameters!.push(KeyValuePairOfStringAndString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EmailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateName"] = this.templateName;
        data["from"] = this.from;
        if (this.to && this.to.constructor === Array) {
            data["to"] = [];
            for (let item of this.to)
                data["to"].push(item);
        }
        data["subject"] = this.subject;
        if (this.parameters && this.parameters.constructor === Array) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEmailCommand {
    templateName?: string | undefined;
    from?: string | undefined;
    to?: string[] | undefined;
    subject?: string | undefined;
    parameters?: KeyValuePairOfStringAndString[] | undefined;
}

export class KeyValuePairOfStringAndString implements IKeyValuePairOfStringAndString {
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: IKeyValuePairOfStringAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): KeyValuePairOfStringAndString {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValuePairOfStringAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IKeyValuePairOfStringAndString {
    key?: string | undefined;
    value?: string | undefined;
}

export class CustomerPreviewResponse implements ICustomerPreviewResponse {
    customers?: CustomerPreview[] | undefined;

    constructor(data?: ICustomerPreviewResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["customers"] && data["customers"].constructor === Array) {
                this.customers = [] as any;
                for (let item of data["customers"])
                    this.customers!.push(CustomerPreview.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerPreviewResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerPreviewResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.customers && this.customers.constructor === Array) {
            data["customers"] = [];
            for (let item of this.customers)
                data["customers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICustomerPreviewResponse {
    customers?: CustomerPreview[] | undefined;
}

export class CustomerPreview implements ICustomerPreview {
    name?: string | undefined;
    accountNumber?: string | undefined;
    matchText?: string | undefined;
    matchProperty!: MatchProperty;

    constructor(data?: ICustomerPreview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.accountNumber = data["accountNumber"];
            this.matchText = data["matchText"];
            this.matchProperty = data["matchProperty"];
        }
    }

    static fromJS(data: any): CustomerPreview {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerPreview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["accountNumber"] = this.accountNumber;
        data["matchText"] = this.matchText;
        data["matchProperty"] = this.matchProperty;
        return data; 
    }
}

export interface ICustomerPreview {
    name?: string | undefined;
    accountNumber?: string | undefined;
    matchText?: string | undefined;
    matchProperty: MatchProperty;
}

export enum MatchProperty {
    Name = 0, 
    AccountNumber = 1, 
    Phone = 2, 
}

export class CustomerPreviewQuery implements ICustomerPreviewQuery {
    branchGroup?: BranchGroup | undefined;
    accountText?: string | undefined;
    maxResultLength!: number;

    constructor(data?: ICustomerPreviewQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchGroup = data["branchGroup"] ? BranchGroup.fromJS(data["branchGroup"]) : <any>undefined;
            this.accountText = data["accountText"];
            this.maxResultLength = data["maxResultLength"];
        }
    }

    static fromJS(data: any): CustomerPreviewQuery {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerPreviewQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchGroup"] = this.branchGroup ? this.branchGroup.toJSON() : <any>undefined;
        data["accountText"] = this.accountText;
        data["maxResultLength"] = this.maxResultLength;
        return data; 
    }
}

export interface ICustomerPreviewQuery {
    branchGroup?: BranchGroup | undefined;
    accountText?: string | undefined;
    maxResultLength: number;
}

export class BranchGroup implements IBranchGroup {
    name?: string | undefined;
    values?: string[] | undefined;

    constructor(data?: IBranchGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["values"] && data["values"].constructor === Array) {
                this.values = [] as any;
                for (let item of data["values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): BranchGroup {
        data = typeof data === 'object' ? data : {};
        let result = new BranchGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.values && this.values.constructor === Array) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data; 
    }
}

export interface IBranchGroup {
    name?: string | undefined;
    values?: string[] | undefined;
}

export class CustomerDetailResponse implements ICustomerDetailResponse {
    customers?: CustomerDetail[] | undefined;
    totalPages!: number;
    totalResults!: number;

    constructor(data?: ICustomerDetailResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["customers"] && data["customers"].constructor === Array) {
                this.customers = [] as any;
                for (let item of data["customers"])
                    this.customers!.push(CustomerDetail.fromJS(item));
            }
            this.totalPages = data["totalPages"];
            this.totalResults = data["totalResults"];
        }
    }

    static fromJS(data: any): CustomerDetailResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDetailResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.customers && this.customers.constructor === Array) {
            data["customers"] = [];
            for (let item of this.customers)
                data["customers"].push(item.toJSON());
        }
        data["totalPages"] = this.totalPages;
        data["totalResults"] = this.totalResults;
        return data; 
    }
}

export interface ICustomerDetailResponse {
    customers?: CustomerDetail[] | undefined;
    totalPages: number;
    totalResults: number;
}

export class CustomerDetail implements ICustomerDetail {
    name?: string | undefined;
    accountNumber?: string | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    matchText?: string | undefined;
    matchProperty!: MatchProperty;

    constructor(data?: ICustomerDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.accountNumber = data["accountNumber"];
            this.address = data["address"];
            this.phoneNumber = data["phoneNumber"];
            this.matchText = data["matchText"];
            this.matchProperty = data["matchProperty"];
        }
    }

    static fromJS(data: any): CustomerDetail {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["accountNumber"] = this.accountNumber;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["matchText"] = this.matchText;
        data["matchProperty"] = this.matchProperty;
        return data; 
    }
}

export interface ICustomerDetail {
    name?: string | undefined;
    accountNumber?: string | undefined;
    address?: string | undefined;
    phoneNumber?: string | undefined;
    matchText?: string | undefined;
    matchProperty: MatchProperty;
}

export class CustomerDetailQuery implements ICustomerDetailQuery {
    branchGroup?: BranchGroup | undefined;
    accountText?: string | undefined;
    page!: number;
    resultsPerPage!: number;

    constructor(data?: ICustomerDetailQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchGroup = data["branchGroup"] ? BranchGroup.fromJS(data["branchGroup"]) : <any>undefined;
            this.accountText = data["accountText"];
            this.page = data["page"];
            this.resultsPerPage = data["resultsPerPage"];
        }
    }

    static fromJS(data: any): CustomerDetailQuery {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDetailQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchGroup"] = this.branchGroup ? this.branchGroup.toJSON() : <any>undefined;
        data["accountText"] = this.accountText;
        data["page"] = this.page;
        data["resultsPerPage"] = this.resultsPerPage;
        return data; 
    }
}

export interface ICustomerDetailQuery {
    branchGroup?: BranchGroup | undefined;
    accountText?: string | undefined;
    page: number;
    resultsPerPage: number;
}

export class BranchGroupsResponse implements IBranchGroupsResponse {
    branchGroups?: BranchGroup[] | undefined;

    constructor(data?: IBranchGroupsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["branchGroups"] && data["branchGroups"].constructor === Array) {
                this.branchGroups = [] as any;
                for (let item of data["branchGroups"])
                    this.branchGroups!.push(BranchGroup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BranchGroupsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BranchGroupsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.branchGroups && this.branchGroups.constructor === Array) {
            data["branchGroups"] = [];
            for (let item of this.branchGroups)
                data["branchGroups"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBranchGroupsResponse {
    branchGroups?: BranchGroup[] | undefined;
}

export class ItemClassesResponse implements IItemClassesResponse {
    itemClasses?: ItemClass[] | undefined;

    constructor(data?: IItemClassesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["itemClasses"] && data["itemClasses"].constructor === Array) {
                this.itemClasses = [] as any;
                for (let item of data["itemClasses"])
                    this.itemClasses!.push(ItemClass.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ItemClassesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ItemClassesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.itemClasses && this.itemClasses.constructor === Array) {
            data["itemClasses"] = [];
            for (let item of this.itemClasses)
                data["itemClasses"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IItemClassesResponse {
    itemClasses?: ItemClass[] | undefined;
}

export class ItemClass implements IItemClass {
    name?: string | undefined;
    value?: string | undefined;
    sections?: ItemClass[] | undefined;

    constructor(data?: IItemClass) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
            if (data["sections"] && data["sections"].constructor === Array) {
                this.sections = [] as any;
                for (let item of data["sections"])
                    this.sections!.push(ItemClass.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ItemClass {
        data = typeof data === 'object' ? data : {};
        let result = new ItemClass();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        if (this.sections && this.sections.constructor === Array) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IItemClass {
    name?: string | undefined;
    value?: string | undefined;
    sections?: ItemClass[] | undefined;
}

export class ItemsResponse implements IItemsResponse {
    items?: Item[] | undefined;

    constructor(data?: IItemsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(Item.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ItemsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ItemsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IItemsResponse {
    items?: Item[] | undefined;
}

export class Item implements IItem {
    itemNumber?: string | undefined;
    description?: string | undefined;
    available!: number;
    price?: string | undefined;
    unitOfMeasure?: string | undefined;
    pso?: string | undefined;

    constructor(data?: IItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.itemNumber = data["itemNumber"];
            this.description = data["description"];
            this.available = data["available"];
            this.price = data["price"];
            this.unitOfMeasure = data["unitOfMeasure"];
            this.pso = data["pso"];
        }
    }

    static fromJS(data: any): Item {
        data = typeof data === 'object' ? data : {};
        let result = new Item();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemNumber"] = this.itemNumber;
        data["description"] = this.description;
        data["available"] = this.available;
        data["price"] = this.price;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["pso"] = this.pso;
        return data; 
    }
}

export interface IItem {
    itemNumber?: string | undefined;
    description?: string | undefined;
    available: number;
    price?: string | undefined;
    unitOfMeasure?: string | undefined;
    pso?: string | undefined;
}

export class ItemsQuery implements IItemsQuery {
    searchType!: SearchType;
    branchGroup?: BranchGroup | undefined;
    section?: ItemClass | undefined;
    searchText?: string | undefined;

    constructor(data?: IItemsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchType = data["searchType"];
            this.branchGroup = data["branchGroup"] ? BranchGroup.fromJS(data["branchGroup"]) : <any>undefined;
            this.section = data["section"] ? ItemClass.fromJS(data["section"]) : <any>undefined;
            this.searchText = data["searchText"];
        }
    }

    static fromJS(data: any): ItemsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ItemsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchType"] = this.searchType;
        data["branchGroup"] = this.branchGroup ? this.branchGroup.toJSON() : <any>undefined;
        data["section"] = this.section ? this.section.toJSON() : <any>undefined;
        data["searchText"] = this.searchText;
        return data; 
    }
}

export interface IItemsQuery {
    searchType: SearchType;
    branchGroup?: BranchGroup | undefined;
    section?: ItemClass | undefined;
    searchText?: string | undefined;
}

export enum SearchType {
    Section = 0, 
    Alpha = 1, 
    ProductNumber = 2, 
}

export class ItemAvailabilityResponse implements IItemAvailabilityResponse {
    itemAvailabilities?: ItemAvailability[] | undefined;

    constructor(data?: IItemAvailabilityResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["itemAvailabilities"] && data["itemAvailabilities"].constructor === Array) {
                this.itemAvailabilities = [] as any;
                for (let item of data["itemAvailabilities"])
                    this.itemAvailabilities!.push(ItemAvailability.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ItemAvailabilityResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ItemAvailabilityResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.itemAvailabilities && this.itemAvailabilities.constructor === Array) {
            data["itemAvailabilities"] = [];
            for (let item of this.itemAvailabilities)
                data["itemAvailabilities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IItemAvailabilityResponse {
    itemAvailabilities?: ItemAvailability[] | undefined;
}

export class ItemAvailability implements IItemAvailability {
    branchNumber!: number;
    branchName?: string | undefined;
    onHand!: number;
    available!: number;
    price?: string | undefined;
    unitOfMeasure?: string | undefined;
    pso?: string | undefined;

    constructor(data?: IItemAvailability) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchNumber = data["branchNumber"];
            this.branchName = data["branchName"];
            this.onHand = data["onHand"];
            this.available = data["available"];
            this.price = data["price"];
            this.unitOfMeasure = data["unitOfMeasure"];
            this.pso = data["pso"];
        }
    }

    static fromJS(data: any): ItemAvailability {
        data = typeof data === 'object' ? data : {};
        let result = new ItemAvailability();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchNumber"] = this.branchNumber;
        data["branchName"] = this.branchName;
        data["onHand"] = this.onHand;
        data["available"] = this.available;
        data["price"] = this.price;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["pso"] = this.pso;
        return data; 
    }
}

export interface IItemAvailability {
    branchNumber: number;
    branchName?: string | undefined;
    onHand: number;
    available: number;
    price?: string | undefined;
    unitOfMeasure?: string | undefined;
    pso?: string | undefined;
}

export class OrderResponse implements IOrderResponse {
    customer?: Order | undefined;

    constructor(data?: IOrderResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customer = data["customer"] ? Order.fromJS(data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IOrderResponse {
    customer?: Order | undefined;
}

export class Order implements IOrder {
    mailingAddress?: Address | undefined;
    phoneNumber?: string | undefined;
    faxNumber?: string | undefined;
    primaryContact?: string | undefined;
    email?: string | undefined;
    csr?: string | undefined;
    terms?: string | undefined;
    territory?: string | undefined;
    priceCode?: string | undefined;
    accountBalance?: string | undefined;
    onOrder?: string | undefined;
    availableCredit?: string | undefined;
    taxId?: string | undefined;
    taxExemptStatus?: string | undefined;
    sicCode?: string | undefined;
    marketingId?: string | undefined;
    lastSaleDate!: Date;

    constructor(data?: IOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mailingAddress = data["mailingAddress"] ? Address.fromJS(data["mailingAddress"]) : <any>undefined;
            this.phoneNumber = data["phoneNumber"];
            this.faxNumber = data["faxNumber"];
            this.primaryContact = data["primaryContact"];
            this.email = data["email"];
            this.csr = data["csr"];
            this.terms = data["terms"];
            this.territory = data["territory"];
            this.priceCode = data["priceCode"];
            this.accountBalance = data["accountBalance"];
            this.onOrder = data["onOrder"];
            this.availableCredit = data["availableCredit"];
            this.taxId = data["taxId"];
            this.taxExemptStatus = data["taxExemptStatus"];
            this.sicCode = data["sicCode"];
            this.marketingId = data["marketingId"];
            this.lastSaleDate = data["lastSaleDate"] ? new Date(data["lastSaleDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Order {
        data = typeof data === 'object' ? data : {};
        let result = new Order();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mailingAddress"] = this.mailingAddress ? this.mailingAddress.toJSON() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber;
        data["faxNumber"] = this.faxNumber;
        data["primaryContact"] = this.primaryContact;
        data["email"] = this.email;
        data["csr"] = this.csr;
        data["terms"] = this.terms;
        data["territory"] = this.territory;
        data["priceCode"] = this.priceCode;
        data["accountBalance"] = this.accountBalance;
        data["onOrder"] = this.onOrder;
        data["availableCredit"] = this.availableCredit;
        data["taxId"] = this.taxId;
        data["taxExemptStatus"] = this.taxExemptStatus;
        data["sicCode"] = this.sicCode;
        data["marketingId"] = this.marketingId;
        data["lastSaleDate"] = this.lastSaleDate ? this.lastSaleDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IOrder {
    mailingAddress?: Address | undefined;
    phoneNumber?: string | undefined;
    faxNumber?: string | undefined;
    primaryContact?: string | undefined;
    email?: string | undefined;
    csr?: string | undefined;
    terms?: string | undefined;
    territory?: string | undefined;
    priceCode?: string | undefined;
    accountBalance?: string | undefined;
    onOrder?: string | undefined;
    availableCredit?: string | undefined;
    taxId?: string | undefined;
    taxExemptStatus?: string | undefined;
    sicCode?: string | undefined;
    marketingId?: string | undefined;
    lastSaleDate: Date;
}

export class Address implements IAddress {
    line1?: string | undefined;
    line2?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    zipCode?: string | undefined;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.line1 = data["line1"];
            this.line2 = data["line2"];
            this.city = data["city"];
            this.state = data["state"];
            this.zipCode = data["zipCode"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        return data; 
    }
}

export interface IAddress {
    line1?: string | undefined;
    line2?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    zipCode?: string | undefined;
}

export class StoreListResponse implements IStoreListResponse {
    storeList?: Store[] | undefined;

    constructor(data?: IStoreListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["storeList"] && data["storeList"].constructor === Array) {
                this.storeList = [] as any;
                for (let item of data["storeList"])
                    this.storeList!.push(Store.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StoreListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StoreListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.storeList && this.storeList.constructor === Array) {
            data["storeList"] = [];
            for (let item of this.storeList)
                data["storeList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStoreListResponse {
    storeList?: Store[] | undefined;
}

export class Store implements IStore {
    storeNumber!: number;
    registers?: Register[] | undefined;

    constructor(data?: IStore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.storeNumber = data["storeNumber"];
            if (data["registers"] && data["registers"].constructor === Array) {
                this.registers = [] as any;
                for (let item of data["registers"])
                    this.registers!.push(Register.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Store {
        data = typeof data === 'object' ? data : {};
        let result = new Store();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeNumber"] = this.storeNumber;
        if (this.registers && this.registers.constructor === Array) {
            data["registers"] = [];
            for (let item of this.registers)
                data["registers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStore {
    storeNumber: number;
    registers?: Register[] | undefined;
}

export class Register implements IRegister {
    lai?: string | undefined;
    name?: string | undefined;
    ip?: string | undefined;
    store!: number;
    gateway?: string | undefined;
    backupPC?: string | undefined;
    type?: string | undefined;
    health?: Health | undefined;
    hostname?: string | undefined;

    constructor(data?: IRegister) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lai = data["lai"];
            this.name = data["name"];
            this.ip = data["ip"];
            this.store = data["store"];
            this.gateway = data["gateway"];
            this.backupPC = data["backupPC"];
            this.type = data["type"];
            this.health = data["health"] ? Health.fromJS(data["health"]) : <any>undefined;
            this.hostname = data["hostname"];
        }
    }

    static fromJS(data: any): Register {
        data = typeof data === 'object' ? data : {};
        let result = new Register();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lai"] = this.lai;
        data["name"] = this.name;
        data["ip"] = this.ip;
        data["store"] = this.store;
        data["gateway"] = this.gateway;
        data["backupPC"] = this.backupPC;
        data["type"] = this.type;
        data["health"] = this.health ? this.health.toJSON() : <any>undefined;
        data["hostname"] = this.hostname;
        return data; 
    }
}

export interface IRegister {
    lai?: string | undefined;
    name?: string | undefined;
    ip?: string | undefined;
    store: number;
    gateway?: string | undefined;
    backupPC?: string | undefined;
    type?: string | undefined;
    health?: Health | undefined;
    hostname?: string | undefined;
}

export class Health implements IHealth {
    isOnline!: boolean;
    isServiceRunning!: boolean;
    isMacCorrect!: boolean;
    ingenicoHealth?: IngenicoHealth | undefined;
    ingenicoInformation?: IngenicoInformation | undefined;

    constructor(data?: IHealth) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isOnline = data["isOnline"];
            this.isServiceRunning = data["isServiceRunning"];
            this.isMacCorrect = data["isMacCorrect"];
            this.ingenicoHealth = data["ingenicoHealth"] ? IngenicoHealth.fromJS(data["ingenicoHealth"]) : <any>undefined;
            this.ingenicoInformation = data["ingenicoInformation"] ? IngenicoInformation.fromJS(data["ingenicoInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Health {
        data = typeof data === 'object' ? data : {};
        let result = new Health();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isOnline"] = this.isOnline;
        data["isServiceRunning"] = this.isServiceRunning;
        data["isMacCorrect"] = this.isMacCorrect;
        data["ingenicoHealth"] = this.ingenicoHealth ? this.ingenicoHealth.toJSON() : <any>undefined;
        data["ingenicoInformation"] = this.ingenicoInformation ? this.ingenicoInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHealth {
    isOnline: boolean;
    isServiceRunning: boolean;
    isMacCorrect: boolean;
    ingenicoHealth?: IngenicoHealth | undefined;
    ingenicoInformation?: IngenicoInformation | undefined;
}

export class IngenicoHealth implements IIngenicoHealth {
    countMsrSwipes!: number;
    countBadTrack1Reads!: number;
    countBadTrack2Reads!: number;
    countBadTrack3Reads!: number;
    countSignatures!: number;
    countReboot!: number;
    deviceName?: string | undefined;
    serialNumber?: string | undefined;
    osVersion?: string | undefined;
    appVersion?: string | undefined;
    securityLibVersion?: string | undefined;
    tdaVersion?: string | undefined;
    eftlVersion?: string | undefined;
    eftpVersion?: string | undefined;
    ramSize!: number;
    flashSize!: number;
    manufactureDate!: Date;
    cpemType?: string | undefined;
    penStatus?: string | undefined;
    appName?: string | undefined;
    manufactureId?: string | undefined;
    digitizerVersion?: string | undefined;
    manufacturingSerialNumber?: string | undefined;
    serviceVersionNumber?: string | undefined;

    constructor(data?: IIngenicoHealth) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countMsrSwipes = data["countMsrSwipes"];
            this.countBadTrack1Reads = data["countBadTrack1Reads"];
            this.countBadTrack2Reads = data["countBadTrack2Reads"];
            this.countBadTrack3Reads = data["countBadTrack3Reads"];
            this.countSignatures = data["countSignatures"];
            this.countReboot = data["countReboot"];
            this.deviceName = data["deviceName"];
            this.serialNumber = data["serialNumber"];
            this.osVersion = data["osVersion"];
            this.appVersion = data["appVersion"];
            this.securityLibVersion = data["securityLibVersion"];
            this.tdaVersion = data["tdaVersion"];
            this.eftlVersion = data["eftlVersion"];
            this.eftpVersion = data["eftpVersion"];
            this.ramSize = data["ramSize"];
            this.flashSize = data["flashSize"];
            this.manufactureDate = data["manufactureDate"] ? new Date(data["manufactureDate"].toString()) : <any>undefined;
            this.cpemType = data["cpemType"];
            this.penStatus = data["penStatus"];
            this.appName = data["appName"];
            this.manufactureId = data["manufactureId"];
            this.digitizerVersion = data["digitizerVersion"];
            this.manufacturingSerialNumber = data["manufacturingSerialNumber"];
            this.serviceVersionNumber = data["serviceVersionNumber"];
        }
    }

    static fromJS(data: any): IngenicoHealth {
        data = typeof data === 'object' ? data : {};
        let result = new IngenicoHealth();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countMsrSwipes"] = this.countMsrSwipes;
        data["countBadTrack1Reads"] = this.countBadTrack1Reads;
        data["countBadTrack2Reads"] = this.countBadTrack2Reads;
        data["countBadTrack3Reads"] = this.countBadTrack3Reads;
        data["countSignatures"] = this.countSignatures;
        data["countReboot"] = this.countReboot;
        data["deviceName"] = this.deviceName;
        data["serialNumber"] = this.serialNumber;
        data["osVersion"] = this.osVersion;
        data["appVersion"] = this.appVersion;
        data["securityLibVersion"] = this.securityLibVersion;
        data["tdaVersion"] = this.tdaVersion;
        data["eftlVersion"] = this.eftlVersion;
        data["eftpVersion"] = this.eftpVersion;
        data["ramSize"] = this.ramSize;
        data["flashSize"] = this.flashSize;
        data["manufactureDate"] = this.manufactureDate ? this.manufactureDate.toISOString() : <any>undefined;
        data["cpemType"] = this.cpemType;
        data["penStatus"] = this.penStatus;
        data["appName"] = this.appName;
        data["manufactureId"] = this.manufactureId;
        data["digitizerVersion"] = this.digitizerVersion;
        data["manufacturingSerialNumber"] = this.manufacturingSerialNumber;
        data["serviceVersionNumber"] = this.serviceVersionNumber;
        return data; 
    }
}

export interface IIngenicoHealth {
    countMsrSwipes: number;
    countBadTrack1Reads: number;
    countBadTrack2Reads: number;
    countBadTrack3Reads: number;
    countSignatures: number;
    countReboot: number;
    deviceName?: string | undefined;
    serialNumber?: string | undefined;
    osVersion?: string | undefined;
    appVersion?: string | undefined;
    securityLibVersion?: string | undefined;
    tdaVersion?: string | undefined;
    eftlVersion?: string | undefined;
    eftpVersion?: string | undefined;
    ramSize: number;
    flashSize: number;
    manufactureDate: Date;
    cpemType?: string | undefined;
    penStatus?: string | undefined;
    appName?: string | undefined;
    manufactureId?: string | undefined;
    digitizerVersion?: string | undefined;
    manufacturingSerialNumber?: string | undefined;
    serviceVersionNumber?: string | undefined;
}

export class IngenicoInformation implements IIngenicoInformation {
    machineName?: string | undefined;
    model?: string | undefined;
    serialNumber?: string | undefined;
    ipAddress?: string | undefined;
    emvEnabled!: boolean;
    nfcEnabled!: boolean;
    encryptionEnabled!: boolean;
    tgzVersion?: string | undefined;

    constructor(data?: IIngenicoInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.machineName = data["machineName"];
            this.model = data["model"];
            this.serialNumber = data["serialNumber"];
            this.ipAddress = data["ipAddress"];
            this.emvEnabled = data["emvEnabled"];
            this.nfcEnabled = data["nfcEnabled"];
            this.encryptionEnabled = data["encryptionEnabled"];
            this.tgzVersion = data["tgzVersion"];
        }
    }

    static fromJS(data: any): IngenicoInformation {
        data = typeof data === 'object' ? data : {};
        let result = new IngenicoInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["machineName"] = this.machineName;
        data["model"] = this.model;
        data["serialNumber"] = this.serialNumber;
        data["ipAddress"] = this.ipAddress;
        data["emvEnabled"] = this.emvEnabled;
        data["nfcEnabled"] = this.nfcEnabled;
        data["encryptionEnabled"] = this.encryptionEnabled;
        data["tgzVersion"] = this.tgzVersion;
        return data; 
    }
}

export interface IIngenicoInformation {
    machineName?: string | undefined;
    model?: string | undefined;
    serialNumber?: string | undefined;
    ipAddress?: string | undefined;
    emvEnabled: boolean;
    nfcEnabled: boolean;
    encryptionEnabled: boolean;
    tgzVersion?: string | undefined;
}

export class StoreResponse implements IStoreResponse {
    store?: Store | undefined;

    constructor(data?: IStoreResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.store = data["store"] ? Store.fromJS(data["store"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StoreResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StoreResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["store"] = this.store ? this.store.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStoreResponse {
    store?: Store | undefined;
}

export class HealthResponse implements IHealthResponse {
    health?: Health | undefined;

    constructor(data?: IHealthResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.health = data["health"] ? Health.fromJS(data["health"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HealthResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HealthResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["health"] = this.health ? this.health.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHealthResponse {
    health?: Health | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}